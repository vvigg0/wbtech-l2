# Задача l2.6

## Задание
Что выведет программа?

Объяснить поведение срезов при передаче их в функцию.
```go
package main

import (
  "fmt"
)

func main() {
  var s = []string{"1", "2", "3"}
  modifySlice(s)
  fmt.Println(s)
}

func modifySlice(i []string) {
  i[0] = "3"
  i = append(i, "4")
  i[1] = "5"
  i = append(i, "6")
}
```

## Решение

Программа выведет:
```
[3 2 3]
```
### Объяснение

```go
type slice struct{
	array unsafe.Pointer
	len int
	cap int
}
```
В функции `main` был создан слайс `s` через литерал - `len = 3,cap = 3`. 

В функцию `modifySlice` передается копия структуры слайса `s`, которая называется `i`, обе эти структуры указывают на один и тот же массив. Эта функция изменяет элементы в слайсе и добавляет новые. 

`i[0] = "3"` изменяет элемент в общем для `i` и `s` массиве.

 `i = append(i, "4")` утыкается в то, что `len+1 > cap`, а значит слайс `i` должен вырасти. 
 
 Растёт слайс путем того, что создается массив, больший предыдущего в 2 раза(если `cap` старого массива `>=threshold(256 на момент написания)`, то растёт по формуле `newcap+=(newcap+threshold*3)>>2`). 
 
 После роста внутри структуры слайса `i` лежит указатель на другой массив и все дальнейшие изменения в слайсе не будут отражаться на слайсе `s`.

#### Дополнительно
Если создать слайс, где `cap>len`, передать его в функцию, добавить в него элемент(ы) , то все элементы, которые вмещались до `cap` можно увидеть и без возврата из функции. При этом поле `len` структуры исходного слайса не изменится.
```go
package main

import "fmt"

func modify(s []int){
	s = append(s,4)
}
func main(){
	s := make([]int,0,4)
	s = append(s,1,2,3)
	modify(s)
	fmt.Println(s)
	fmt.Println(s[:4])
}
```
Вывод:
```
[1 2 3]
[1 2 3 4]
```