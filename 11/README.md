# Задача l2.11

# Поиск анаграмм в словаре

Задание: написать функцию, которая находит все множества анаграмм по заданному словарю.

На вход подаётся срез строк (русские слова в Unicode).  
На выходе — `map[string][]string`, где:
- ключ — первое встреченное слово множества анаграмм,
- значение — срез всех слов этого множества, приведённых к нижнему регистру и отсортированных по возрастанию,
- множества из одного слова не выводятся (слова без анаграмм игнорируются).

Оценка эффективности: решение должно работать за линейно-логарифмическое время относительно количества слов (допустимо `n * m log m`, где `m` — средняя длина слова для сортировки букв).

---

## Пример

Вход:
`["пятак", "пятка", "тяпка", "листок", "слиток", "столик", "стол"]`

Результат (порядок ключей в `map` не важен):
- `"пятак":  ["пятак", "пятка", "тяпка"]`
- `"листок": ["листок", "слиток", "столик"]`

Слово `"стол"` отсутствует в результатах, так как не имеет анаграмм.

---

## Структура проекта и где лежит решение

Каталог задания:

Внутри лежат два независимых варианта решения:

- `1/main.go` — вариант 1 (частотная сигнатура, без сортировки букв)
- `2/main.go` — вариант 2 (сигнатура через сортировку символов)

Оба варианта:
- приводят слова к нижнему регистру (`strings.ToLower`),
- удаляют дубликаты слов после lower-case,
- группируют слова по сигнатуре,
- выбрасывают группы размером 1,
- сортируют слова внутри группы по возрастанию,
- используют первое встретившееся слово группы в качестве ключа результирующей `map`.

---

## Вариант 1: частотная сигнатура (1/main.go)

### Идея
Для каждого слова строится сигнатура как массив счётчиков букв (размер 33), где каждый индекс соответствует количеству вхождений конкретной буквы русского алфавита. Буква `ё` учитывается отдельно.

Слова с одинаковой частотной сигнатурой попадают в одну группу анаграмм.

### Почему это работает
У анаграмм одинаковый набор букв с одинаковой кратностью, значит частотный вектор совпадает.

### Сложность
Построение сигнатуры: `O(m)` на слово.  
Итоговая сложность: `O(n*m + Σ k_i log k_i)` (сортировка внутри групп), что укладывается в требования и обычно быстрее варианта с сортировкой букв.

---

## Вариант 2: сигнатура через сортировку рун (2/main.go)

### Идея
Для каждого слова:
1) привести к нижнему регистру,
2) преобразовать в `[]rune`,
3) отсортировать руны,
4) строка из отсортированных рун становится сигнатурой.

Слова с одинаковой сигнатурой попадают в одну группу анаграмм.

### Почему это работает
Если отсортировать буквы анаграмм, получится одна и та же последовательность символов.

### Сложность
Построение сигнатуры: `O(m log m)` на слово (из-за сортировки рун).  
Итоговая сложность: `O(n*m log m + Σ k_i log k_i)` — соответствует требованию задачи.


### Ключевые детали требований

- Все слова приводятся к нижнему регистру до обработки.

- Дубликаты слов исключаются (после lower-case).

- Группы из одного слова не попадают в результат.

- Значения (списки слов в каждой группе) сортируются по возрастанию.

- Ключ результата — первое встреченное слово группы (фиксируется до сортировки списка группы).
